# Sheet-Only Multi-Approver Workflow Design

## Goals and constraints
- Deliver optional multi-approver gating for control-sheet edits without relying on custom menus (sheet editors cannot run Apps Script menu handlers).
- All interactions for requesting, approving, or denying changes must happen through sheet edits and validations that the installable triggers can observe.
- Keep the default behavior unchanged when the required approval count is `1`.
See `docs/SHEET_ACCESS_POLICY.md` for the centralized sheet access policy enforced by the script.

## Core sheet surfaces
### Config sheet additions
- `ApprovalsEnabled` (boolean) – turns the feature on/off. Default: `FALSE` to preserve current behavior.
- `RequiredApprovals` (number) – minimum distinct approvers for each request. Default: `1` (one approver required). Maximum: `3`, and cannot exceed active Sheet Editors.
- `ApprovalExpiryHours` (number, optional) – auto-expire stale requests (e.g., 72 hours).
Note: changes to `ApprovalsEnabled` or `RequiredApprovals` are blocked while any ChangeRequests are pending.

### ChangeRequests sheet (new)
A dedicated table that sheet editors can edit directly. Suggested columns:

| Column | Purpose |
| --- | --- |
| `RequestId` | Unique ID (generated by the script or provided by the requester if simple). |
| `RequestedBy` | Email of requester (manual entry; script overwrites with the editor email if captured from the edit event). |
| `RequestedAt` | Timestamp (data validation rule can default to NOW(); script normalizes). |
| `TargetSheet` | Name of control sheet to change (e.g., `ManagedFolders`, `Permissions`). |
| `TargetRowKey` | Primary key / identifier for the target row (e.g., folder ID or user+folder key). |
| `Action` | `ADD`, `UPDATE`, or `DELETE`. |
| `ProposedRowSnapshot` | Serialized values for the intended row (e.g., JSON or pipe-separated columns). |
| `Status` | `PENDING`, `APPROVED`, `DENIED`, `CANCELLED`, `APPLIED`, `EXPIRED`. Data validation enforces allowed values. |
| `ApprovalsNeeded` | Derived from `RequiredApprovals`; computed by script for each row. |
| `Approver_1..N` | Each column holds one approver email. Deduplicate and reject the requester. |
| `DenyReason` | Free text when `Status = DENIED` or `CANCELLED`. |
| `AppliedAt` | Timestamp when the change is pushed to the control sheet. |

Note: when `ApprovalsEnabled = FALSE`, the `ChangeRequests` sheet may be hidden. Approver columns are expanded automatically to match the current `RequiredApprovals` setting.

### Optional views
- **ChangeQueue**: A filtered view or helper sheet showing rows where `Status = PENDING` or `Status = APPROVED` with remaining approvals.
- **Health banner row**: A top row in `ChangeRequests` that the script updates with warnings (e.g., “Required approvals (3) exceed available sheet editors (2)”).

## End-to-end workflow (no menus)
1. **Request capture**
   - Requester fills a new row in `ChangeRequests` with `Action`, `TargetSheet`, `TargetRowKey`, and `ProposedRowSnapshot`.
   - Data validation on `Status` defaults to `PENDING`. A simple checkbox (TRUE/FALSE) can set `ApprovalsEnabled` on the Config sheet.
   - An installable `onChange`/time-driven trigger normalizes the row (fills `RequestId`, `RequestedBy`, `RequestedAt`, `ApprovalsNeeded`).
   - The script refuses to stage changes if `RequiredApprovals` exceeds the distinct sheet editors, and writes the warning into the banner row.

2. **Approval / denial via cells**
   - Other sheet editors type their email into the next empty `Approver_*` column. Data validation can restrict entries to the `SheetEditors` list.
   - The script tallies unique approvers on each trigger run. When the count meets `ApprovalsNeeded`, it flips `Status` to `APPROVED`.
   - To deny, an editor sets `Status` to `DENIED` or `CANCELLED` and can add a `DenyReason`. The script marks the row immutable once denied or cancelled.

3. **Applying approved changes**
   - The AutoSync loop (or a dedicated time-driven trigger) scans for rows with `Status = APPROVED`.
   - For each approved row:
     - Validate the target row still matches the latest control-sheet state (to avoid clobbering newer edits).
     - Apply the change to the target control sheet:
       - `ADD`: append the proposed row.
       - `UPDATE`: match by `TargetRowKey` and replace/update columns.
       - `DELETE`: remove or mark inactive by key.
     - Log success/failure in the Log sheet, set `Status = APPLIED`, and record `AppliedAt`.
   - If validation fails (e.g., key missing), set `Status = DENIED` with a reason.
   - When approvals are enabled, manual sync menu actions skip direct changes and only process approved ChangeRequests.

4. **Expiry and cleanup**
   - A scheduled trigger checks `RequestedAt` + `ApprovalExpiryHours`; if exceeded and still pending, set `Status = EXPIRED` and log it.
   - Provide a filter view or cleanup script to purge old `APPLIED`/`EXPIRED` rows after a retention period.

## Safeguards and UX notes (sheet-first)
- **Protected ranges**: Protect the header and computed columns in `ChangeRequests`; only allow editing of request input cells, `Status`, and `Approver_*` columns.
- **Color cues**: Conditional formatting for `PENDING` (yellow), `APPROVED` (green), `DENIED/EXPIRED` (red/grey) to guide sheet editors without menus.
- **Error messaging**: The top banner row shows the latest validation error (e.g., missing `TargetRowKey`, approvals > editors, or malformed `ProposedRowSnapshot`).
- **No self-approval**: The script ignores `Approver_*` entries matching `RequestedBy`.
- **Idempotency**: The script tracks `RequestId` in Document Properties to avoid reapplying already-applied rows if a trigger reruns.

## Rollout approach
1. Ship the new sheet templates (`ChangeRequests`, optional `ChangeQueue`) and Config entries in a migration script.
2. Add validation hooks to skip AutoSync edits when `ApprovalsEnabled = FALSE` or `RequiredApprovals = 1` (preserves existing behavior).
3. Introduce the new triggers: one for normalizing requests (on change) and another inside AutoSync to apply `APPROVED` rows.
4. Update the user guides to explain how to fill `ChangeRequests` and how many approvals are required.

## Manual test plan (sheet-only interactions)
These scenarios validate the approval pipeline without Apps Script menus. Reset any banner warnings between runs and ensure installable triggers are enabled (on-change normalization and AutoSync/time-driven processing).

1. **Baseline behavior (feature off)**
   - Set `ApprovalsEnabled = FALSE` and `RequiredApprovals = 1` on Config.
   - Edit a control sheet row directly and run a normal sync.
   - Expect: no `ChangeRequests` interaction; sync behaves as it does today.

2. **Single-approver path (default threshold)**
   - Set `ApprovalsEnabled = TRUE`, `RequiredApprovals = 1`.
   - Add a `PENDING` row in `ChangeRequests` for an `ADD` or `UPDATE` action.
   - Trigger processing (on-change/AutoSync) and confirm the row flips to `APPROVED` then `APPLIED` without extra approvers.
   - Expect: target control sheet reflects the change; `AppliedAt` is set; banner has no warnings.

3. **Happy path with multiple approvers**
   - Set `RequiredApprovals = 2` (or higher, within available editors).
   - Requester adds a `PENDING` row; note `ApprovalsNeeded` is populated and requester email captured.
   - Two distinct sheet editors type their emails into `Approver_*` columns.
   - After trigger run, expect `Status` transitions to `APPROVED`, then `APPLIED`, with both approvers recorded and requester not counted.

4. **Requester cannot self-approve**
   - With approvals enabled, add a request and have the requester fill the first `Approver_*` cell with their own email.
   - Trigger processing should leave `Status = PENDING` and a banner or note indicating self-approval is ignored.
   - Add a second distinct approver; expect approval proceeds only after sufficient non-requester emails are present.

5. **Insufficient sheet editors warning**
   - Temporarily remove editors from `SheetEditors` so the count is lower than `RequiredApprovals`.
   - Add a `PENDING` request.
   - Expect: processing leaves request pending/blocked, updates the banner row with a warning about unavailable approvers, and does not apply changes.
   - Restore editors and re-run processing; confirm warning clears and the request can advance with valid approvers.

6. **Denial / cancellation flow**
   - Add a `PENDING` request with approvals enabled.
   - An editor sets `Status = DENIED` (optionally fills `DenyReason`).
   - Expect: row becomes immutable for further approvals; no changes are applied to control sheets; AutoSync skips it and logs denial.
   - Repeat with `Status = CANCELLED` to mirror requester withdrawal.

7. **Expiry handling**
   - Configure `ApprovalExpiryHours` to a small value (e.g., 0.01) for testing.
   - Add a `PENDING` request with no approvers and wait past the threshold, then trigger processing.
   - Expect: `Status` flips to `EXPIRED`, and the request is not applied. Reset expiry to normal after test.

8. **Conflict/validation guardrail**
   - Create two requests targeting the same `TargetRowKey` (one `UPDATE`, one `DELETE`).
   - Approve both and run processing.
   - Expect: the second request should be blocked or marked `DENIED` with a reason indicating conflict or missing key, preventing double-apply.

9. **AutoSync integration**
   - With `ApprovalsEnabled = TRUE`, place at least one approved request and one pending request.
   - Run AutoSync/full sync.
   - Expect: approved request is applied before normal sync steps; pending request remains untouched; logs reflect ordered processing.

10. **Post-apply cleanup**
   - After successful applications, verify that `Status = APPLIED`, `AppliedAt` is populated, and no residual notes exist.
   - Optionally clear old applied/expired rows and confirm banner remains clear.

## Limitations
- Approvals remain asynchronous; users should not expect immediate application after adding approvers because triggers run on schedule.
- Free-form `ProposedRowSnapshot` requires clear formatting guidance to avoid malformed updates; consider providing helper formulas (e.g., `TEXTJOIN`) to assemble payloads.
- Concurrent requests touching the same `TargetRowKey` should be blocked or queued by the script to avoid conflicts.

## Implementation effort and risk outlook
- **Complexity level: moderate, bounded** – The feature layers on existing trigger-driven flows and sheet-based validation, so it does not require new infrastructure. Most effort sits in schema migration, trigger wiring, and idempotent state handling rather than novel APIs.
- **Safe-by-default toggle** – With `ApprovalsEnabled = FALSE` or `RequiredApprovals = 1`, current behavior is preserved. This containment limits blast radius during rollout and allows phased enablement per environment.
- **Key risk areas to watch**:
  - **Conflict resolution**: Requests that overlap on the same row/key need guardrails to prevent clobbering. Expect to add conflict checks and clear error messaging.
  - **Data quality of proposed changes**: Since requests are cell-driven, malformed snapshots can lead to denial loops. Strong validation, protected columns, and helper formulas reduce this risk.
  - **Trigger throughput and quotas**: Additional time-driven/on-change work increases Apps Script execution counts. Keeping logic lightweight and batching approvals in the AutoSync loop mitigates quota pressure.
  - **Approver availability**: If `RequiredApprovals` exceeds available editors or editors are inactive, requests can stall. The banner warnings and denial/expiry flow surface this early.
- **Overall expectation** – With careful validation and conflict handling, this is a reasonable and safe enhancement that should be implementable without excessive effort. The main work items are schema setup, approval counting, and sync gating; each is well-scoped and incremental.
